# Issue 0004: MVC分離 実装計画

## Issue概要
現在の `main.py` は単一ファイルに全ての責務が集中しており、以下の問題が発生しています:
1. **View層の分離不足**: 330行以上のHTML/CSS/JSが埋め込まれている
2. **Service層の不在**: ビジネスロジックがコントローラに直接記述されている
3. **ask_ai()の肥大化**: 1つの関数で5つの責務を持つ

本計画では、MVCアーキテクチャの導入により保守性とテスト容易性を向上させます。

## 現状のアーキテクチャ分析

### 既存の構成
- **フレームワーク**: FastAPI (単一ファイル構成)
- **主要ファイル**: `main.py` (681行)
- **構造**: モノリシックな単一ファイル
- **依存関係**: FastAPI, OpenAI, Pydantic

### 現在の責務混在状況

#### 1. index() 関数 (228-560行目)
- **問題**: 332行のHTML/CSS/JavaScriptが文字列として埋め込み
- **影響**:
  - フロントエンドの変更にPythonファイルの編集が必要
  - シンタックスハイライトやリンティングが効かない
  - バージョン管理の差分が見づらい

#### 2. save_file() 関数 (563-599行目)
- **責務**:
  - バリデーション (571-581行目)
  - ファイルI/O (586-588行目)
  - Git操作呼び出し (591行目)
- **問題**: ビジネスロジックとインフラ層が混在

#### 3. ask_ai() 関数 (602-674行目)
- **責務**:
  1. モード検証 (615-620行目)
  2. プロンプト構築 (624行目)
  3. OpenAI API呼び出し (627-633行目)
  4. ファイル名生成 (636-645行目)
  5. ファイル保存 (648-657行目)
  6. Git操作呼び出し (660行目)
- **問題**: 単一責任原則違反、テストが困難

#### 4. git_commit_and_push() 関数 (141-201行目)
- **責務**: Git add/commit/push の実行
- **問題**: インフラ層の処理がコントローラと同じファイルに存在

## 目標アーキテクチャ

### ディレクトリ構成
```
obsidian-synapsis/
├── main.py                    # アプリケーションエントリーポイント (簡素化)
├── config.py                  # 設定管理
├── dependencies.py            # DIコンテナ
├── controllers/               # コントローラ層
│   ├── __init__.py
│   ├── health_controller.py
│   ├── save_controller.py
│   ├── ai_controller.py
│   └── mode_controller.py
├── services/                  # サービス層 (ビジネスロジック)
│   ├── __init__.py
│   ├── ai_service.py         # AI処理
│   ├── file_service.py       # ファイル操作
│   ├── git_service.py        # Git操作
│   └── mode_service.py       # モード管理
├── models/                    # データモデル
│   ├── __init__.py
│   ├── requests.py           # リクエストモデル
│   └── responses.py          # レスポンスモデル
├── templates/                 # Jinja2テンプレート
│   └── index.html
├── static/                    # 静的ファイル
│   ├── css/
│   │   └── style.css
│   └── js/
│       └── app.js
├── modes_config.json
└── pyproject.toml
```

### 依存関係の追加
```toml
[project]
dependencies = [
    "fastapi>=0.115.0",
    "uvicorn[standard]>=0.32.0",
    "openai>=1.0.0",
    "jinja2>=3.1.0",        # 新規追加
]
```

## 実装ステップ

### Phase 1: プロジェクト構造の準備 (影響度: 低)

#### Step 1.1: ディレクトリ作成
```bash
mkdir -p controllers services models templates static/css static/js
touch controllers/__init__.py services/__init__.py models/__init__.py
```

#### Step 1.2: 依存関係の追加
- `pyproject.toml` に `jinja2>=3.1.0` を追加
- `uv pip install -e .` で再インストール

**影響範囲**: なし (既存コード変更なし)
**リスク**: 低
**所要時間**: 5分

---

### Phase 2: モデル層の分離 (影響度: 低)

#### Step 2.1: リクエストモデルの分離
**新規ファイル**: `models/requests.py`

```python
"""リクエストモデル定義"""
from pydantic import BaseModel


class SaveRequest(BaseModel):
    """ファイル保存リクエストのスキーマ"""
    filename: str | None = None
    content: str


class AskAIRequest(BaseModel):
    """AI問い合わせリクエストのスキーマ"""
    content: str
    mode_id: str = "general"
    filename: str | None = None
```

#### Step 2.2: レスポンスモデルの分離
**新規ファイル**: `models/responses.py`

```python
"""レスポンスモデル定義"""
from pydantic import BaseModel


class SaveResponse(BaseModel):
    """ファイル保存レスポンスのスキーマ"""
    success: bool
    filepath: str
    message: str
    git_pushed: bool = False
    git_error: str | None = None


class AskAIResponse(BaseModel):
    """AI問い合わせレスポンスのスキーマ"""
    success: bool
    ai_response: str
    filepath: str
    message: str
    git_pushed: bool = False
    git_error: str | None = None


class ModeConfig(BaseModel):
    """モード設定のスキーマ"""
    id: str
    name: str
    prompt_template: str
    save_dir: str
    description: str


class GetModesResponse(BaseModel):
    """モード一覧取得レスポンスのスキーマ"""
    modes: list[ModeConfig]
    default_mode: str
```

#### Step 2.3: main.pyの更新
```python
# main.py の該当部分を以下に置き換え
from models.requests import SaveRequest, AskAIRequest
from models.responses import (
    SaveResponse, AskAIResponse, ModeConfig, GetModesResponse
)
```

**影響範囲**: main.pyのimport文のみ
**リスク**: 低 (コピー&ペーストのみ)
**所要時間**: 10分
**検証方法**: `uvicorn main:app --reload` で起動確認

---

### Phase 3: 設定管理の分離 (影響度: 低)

#### Step 3.1: 設定ファイルの作成
**新規ファイル**: `config.py`

```python
"""アプリケーション設定"""
import json
import os
from pathlib import Path
from models.responses import ModeConfig


class Config:
    """アプリケーション設定クラス"""

    # ディレクトリパス
    BASE_DIR = Path(__file__).parent
    DATA_DIR = BASE_DIR / "data"
    CONFIG_FILE = BASE_DIR / "modes_config.json"
    TEMPLATE_DIR = BASE_DIR / "templates"
    STATIC_DIR = BASE_DIR / "static"

    # OpenAI設定
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    OPENAI_MODEL = "gpt-4o"

    # モード設定 (遅延ロード)
    _modes_config: dict | None = None

    @classmethod
    def load_modes_config(cls) -> dict:
        """モード設定ファイルを読み込む"""
        if cls._modes_config is not None:
            return cls._modes_config

        if not cls.CONFIG_FILE.exists():
            raise RuntimeError(f"モード設定ファイルが見つかりません: {cls.CONFIG_FILE}")

        try:
            config_data = json.loads(cls.CONFIG_FILE.read_text(encoding="utf-8"))
            cls._modes_config = config_data
            print(f"モード設定を読み込みました: {len(config_data['modes'])}個のモード")
            return config_data
        except Exception as e:
            raise RuntimeError(f"モード設定の読み込みに失敗: {e}") from e

    @classmethod
    def get_mode_by_id(cls, mode_id: str) -> ModeConfig | None:
        """モードIDからモード設定を取得"""
        config = cls.load_modes_config()
        for mode_data in config["modes"]:
            if mode_data["id"] == mode_id:
                return ModeConfig(**mode_data)
        return None

    @classmethod
    def validate(cls) -> None:
        """設定の妥当性をチェック"""
        if not cls.OPENAI_API_KEY:
            raise RuntimeError("OPENAI_API_KEY環境変数が設定されていません")
        cls.load_modes_config()
```

**影響範囲**: main.pyのグローバル変数と関数
**リスク**: 低
**所要時間**: 15分

---

### Phase 4: Service層の実装 (影響度: 中)

#### Step 4.1: Git操作サービス
**新規ファイル**: `services/git_service.py`

```python
"""Git操作サービス"""
import asyncio
from datetime import datetime
from pathlib import Path
from zoneinfo import ZoneInfo


class GitService:
    """Git操作を管理するサービスクラス"""

    @staticmethod
    async def commit_and_push(repo_dir: Path) -> tuple[bool, str | None]:
        """
        Git commit & push を実行

        Args:
            repo_dir: リポジトリのルートディレクトリ

        Returns:
            (成功フラグ, エラーメッセージ or None)
        """
        try:
            # JST現在時刻を取得
            jst = ZoneInfo("Asia/Tokyo")
            now = datetime.now(jst)
            commit_message = f"Synapsis: {now.strftime('%Y-%m-%d %H:%M:%S')}"

            # git add . を実行
            add_process = await asyncio.create_subprocess_exec(
                "git", "add", ".",
                cwd=str(repo_dir),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            await add_process.communicate()

            if add_process.returncode != 0:
                return False, "git add failed"

            # git commit を実行
            commit_process = await asyncio.create_subprocess_exec(
                "git", "commit", "-m", commit_message,
                cwd=str(repo_dir),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, stderr = await commit_process.communicate()

            # commitがない場合(nothing to commit)は成功とみなす
            if commit_process.returncode != 0:
                stderr_text = stderr.decode("utf-8")
                if "nothing to commit" in stderr_text:
                    return True, None
                return False, f"git commit failed: {stderr_text}"

            # git push --force を実行
            push_process = await asyncio.create_subprocess_exec(
                "git", "push", "--force",
                cwd=str(repo_dir),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, stderr = await push_process.communicate()

            if push_process.returncode != 0:
                stderr_text = stderr.decode("utf-8")
                return False, f"git push failed: {stderr_text}"

            return True, None

        except Exception as e:
            return False, f"git operation error: {str(e)}"
```

#### Step 4.2: ファイル操作サービス
**新規ファイル**: `services/file_service.py`

```python
"""ファイル操作サービス"""
from datetime import datetime
from pathlib import Path
from fastapi import HTTPException


class FileService:
    """ファイル操作を管理するサービスクラス"""

    @staticmethod
    def generate_filename(prefix: str = "", extension: str = "md") -> str:
        """
        タイムスタンプベースのファイル名を生成

        Args:
            prefix: ファイル名のプレフィックス
            extension: 拡張子 (デフォルト: md)

        Returns:
            生成されたファイル名
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        if prefix:
            return f"{prefix}_{timestamp}.{extension}"
        return f"{timestamp}.{extension}"

    @staticmethod
    def sanitize_filename(filename: str) -> str:
        """
        ファイル名をサニタイズ (パストラバーサル対策)

        Args:
            filename: サニタイズするファイル名

        Returns:
            安全なファイル名

        Raises:
            HTTPException: 無効なファイル名の場合
        """
        safe_filename = Path(filename).name
        if not safe_filename:
            raise HTTPException(status_code=400, detail="無効なファイル名です")
        return safe_filename

    @staticmethod
    def save_text_file(filepath: Path, content: str) -> None:
        """
        テキストファイルを保存

        Args:
            filepath: 保存先パス
            content: 保存する内容

        Raises:
            HTTPException: ファイル保存失敗時
        """
        try:
            filepath.write_text(content, encoding="utf-8")
        except OSError as e:
            raise HTTPException(
                status_code=500,
                detail=f"ファイル保存に失敗: {e}"
            ) from e

    @staticmethod
    def build_ai_response_content(
        mode_name: str,
        user_input: str,
        ai_response: str
    ) -> str:
        """
        AI回答をMarkdown形式で構築

        Args:
            mode_name: モード名
            user_input: ユーザー入力
            ai_response: AI回答

        Returns:
            Markdown形式の文字列
        """
        return (
            f"# {mode_name}\n\n"
            f"## 入力\n\n{user_input}\n\n"
            f"## AI回答\n\n{ai_response}\n"
        )
```

#### Step 4.3: AI処理サービス
**新規ファイル**: `services/ai_service.py`

```python
"""AI処理サービス"""
from openai import OpenAI
from fastapi import HTTPException


class AIService:
    """AI処理を管理するサービスクラス"""

    def __init__(self, api_key: str, model: str = "gpt-4o"):
        """
        Args:
            api_key: OpenAI APIキー
            model: 使用するモデル名
        """
        self.client = OpenAI(api_key=api_key)
        self.model = model

    def build_prompt_from_template(self, template: str, content: str) -> str:
        """
        プロンプトテンプレートにコンテンツを埋め込む

        Args:
            template: プロンプトテンプレート
            content: ユーザー入力

        Returns:
            構築されたプロンプト
        """
        return template.format(content=content)

    def ask(self, prompt: str, temperature: float = 0.7) -> str:
        """
        AIに質問して回答を取得

        Args:
            prompt: プロンプト
            temperature: 温度パラメータ

        Returns:
            AI回答

        Raises:
            HTTPException: API呼び出し失敗時
        """
        try:
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[{"role": "user", "content": prompt}],
                temperature=temperature,
            )
            return response.choices[0].message.content
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"AI処理中にエラーが発生しました: {e!s}"
            ) from e
```

#### Step 4.4: モード管理サービス
**新規ファイル**: `services/mode_service.py`

```python
"""モード管理サービス"""
from config import Config
from models.responses import ModeConfig, GetModesResponse
from fastapi import HTTPException


class ModeService:
    """モード管理を行うサービスクラス"""

    @staticmethod
    def get_modes() -> GetModesResponse:
        """
        利用可能なモード一覧を取得

        Returns:
            モード一覧とデフォルトモード
        """
        config = Config.load_modes_config()
        modes = [ModeConfig(**mode_data) for mode_data in config["modes"]]
        return GetModesResponse(
            modes=modes,
            default_mode=config["default_mode"]
        )

    @staticmethod
    def get_mode_by_id(mode_id: str) -> ModeConfig:
        """
        モードIDからモード設定を取得

        Args:
            mode_id: モードID

        Returns:
            モード設定

        Raises:
            HTTPException: 無効なモードIDの場合
        """
        mode = Config.get_mode_by_id(mode_id)
        if mode is None:
            raise HTTPException(
                status_code=400,
                detail=f"無効なモードID: {mode_id}"
            )
        return mode
```

**影響範囲**: 新規ファイルのみ
**リスク**: 低
**所要時間**: 30分

---

### Phase 5: View層の分離 (影響度: 中)

#### Step 5.1: CSSファイルの作成
**新規ファイル**: `static/css/style.css`

```css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    background: #1e1e1e;
    color: #e0e0e0;
    height: 100vh;
    overflow: hidden;
}

.container {
    display: flex;
    height: 100vh;
}

/* 左ペイン: タブナビゲーション */
.sidebar {
    width: 250px;
    background: #252525;
    border-right: 1px solid #444;
    padding: 20px 0;
    overflow-y: auto;
}

.sidebar h2 {
    color: #7c3aed;
    padding: 0 20px 20px;
    font-size: 24px;
}

.mode-tab {
    padding: 16px 20px;
    cursor: pointer;
    transition: all 0.2s;
    border-left: 3px solid transparent;
}

.mode-tab:hover {
    background: #2d2d2d;
}

.mode-tab.active {
    background: #2d2d2d;
    border-left-color: #7c3aed;
}

.mode-tab-name {
    font-size: 16px;
    font-weight: 500;
    margin-bottom: 4px;
}

.mode-tab-desc {
    font-size: 13px;
    color: #999;
}

/* 右ペイン: メインコンテンツ */
.main-content {
    flex: 1;
    padding: 40px;
    overflow-y: auto;
}

.mode-title {
    color: #7c3aed;
    font-size: 28px;
    margin-bottom: 8px;
}

.mode-description {
    color: #999;
    margin-bottom: 24px;
    font-size: 14px;
}

textarea {
    width: 100%;
    height: 300px;
    padding: 16px;
    font-size: 16px;
    border: 1px solid #444;
    border-radius: 8px;
    background: #2d2d2d;
    color: #e0e0e0;
    resize: vertical;
    font-family: inherit;
}

.button-group {
    margin-top: 16px;
    display: flex;
    gap: 12px;
}

button {
    padding: 12px 32px;
    font-size: 16px;
    background: #7c3aed;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.2s;
}

button:hover { background: #6d28d9; }
button:disabled { background: #666; cursor: not-allowed; }
#askAIBtn { background: #10b981; }
#askAIBtn:hover { background: #059669; }

#message {
    margin-top: 16px;
    padding: 12px;
    border-radius: 8px;
    display: none;
}

.success { background: #065f46; display: block !important; }
.error { background: #991b1b; display: block !important; }
.warning { background: #92400e; display: block !important; }

#aiResponse {
    margin-top: 24px;
    padding: 20px;
    background: #2d2d2d;
    border-radius: 8px;
    display: none;
}

#aiResponse h3 {
    color: #10b981;
    margin-top: 0;
    margin-bottom: 16px;
}

#aiResponseContent {
    white-space: pre-wrap;
    line-height: 1.6;
}
```

#### Step 5.2: JavaScriptファイルの作成
**新規ファイル**: `static/js/app.js`

```javascript
let currentMode = null;
let modesData = null;

// ページ読み込み時にモード一覧を取得
async function loadModes() {
    try {
        const res = await fetch('/modes');
        const data = await res.json();
        modesData = data;

        // タブを生成
        const tabsContainer = document.getElementById('modeTabs');
        data.modes.forEach(mode => {
            const tab = document.createElement('div');
            tab.className = 'mode-tab';
            tab.onclick = () => selectMode(mode.id);
            tab.innerHTML = `
                <div class="mode-tab-name">${mode.name}</div>
                <div class="mode-tab-desc">${mode.description}</div>
            `;
            tab.dataset.modeId = mode.id;
            tabsContainer.appendChild(tab);
        });

        // デフォルトモードを選択
        selectMode(data.default_mode);
    } catch (e) {
        showMessage('モード読み込みエラー: ' + e.message, 'error');
    }
}

// モードを選択
function selectMode(modeId) {
    const mode = modesData.modes.find(m => m.id === modeId);
    if (!mode) return;

    currentMode = mode;

    // タブのアクティブ状態を更新
    document.querySelectorAll('.mode-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.modeId === modeId);
    });

    // タイトルと説明を更新
    document.getElementById('modeTitle').textContent = mode.name;
    document.getElementById('modeDescription').textContent = mode.description;

    // AI回答を非表示
    document.getElementById('aiResponse').style.display = 'none';
    document.getElementById('message').style.display = 'none';
}

// 保存のみ
async function saveContent() {
    const content = document.getElementById('content').value;
    const btn = document.getElementById('saveBtn');

    if (!content.trim()) {
        showMessage('内容を入力してください', 'error');
        return;
    }

    btn.disabled = true;
    btn.textContent = '保存中...';

    try {
        const res = await fetch('/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content })
        });
        const data = await res.json();

        if (res.ok) {
            let message = data.message;

            // Git push結果を追加
            if (data.git_pushed) {
                message += ' (Git push成功)';
            } else if (data.git_error) {
                message += ` (Git push失敗: ${data.git_error})`;
            }

            showMessage(message, data.git_pushed ? 'success' : 'warning');
            document.getElementById('content').value = '';
        } else {
            showMessage(data.detail || '保存に失敗しました', 'error');
        }
    } catch (e) {
        showMessage('エラー: ' + e.message, 'error');
    } finally {
        btn.disabled = false;
        btn.textContent = '保存のみ';
    }
}

// AIに質問
async function askAI() {
    const content = document.getElementById('content').value;
    const btn = document.getElementById('askAIBtn');
    const responseDiv = document.getElementById('aiResponse');
    const responseContent = document.getElementById('aiResponseContent');

    if (!content.trim()) {
        showMessage('内容を入力してください', 'error');
        return;
    }

    if (!currentMode) {
        showMessage('モードが選択されていません', 'error');
        return;
    }

    btn.disabled = true;
    btn.textContent = 'AI処理中...';
    responseDiv.style.display = 'none';

    try {
        const res = await fetch('/ask-ai', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                content,
                mode_id: currentMode.id
            })
        });
        const data = await res.json();

        if (res.ok) {
            let message = data.message;

            // Git push結果を追加
            if (data.git_pushed) {
                message += ' (Git push成功)';
            } else if (data.git_error) {
                message += ` (Git push失敗: ${data.git_error})`;
            }

            showMessage(message, data.git_pushed ? 'success' : 'warning');
            responseContent.textContent = data.ai_response;
            responseDiv.style.display = 'block';
        } else {
            showMessage(data.detail || 'AI処理に失敗しました', 'error');
        }
    } catch (e) {
        showMessage('エラー: ' + e.message, 'error');
    } finally {
        btn.disabled = false;
        btn.textContent = 'AIに質問';
    }
}

function showMessage(text, type) {
    const msg = document.getElementById('message');
    msg.textContent = text;
    msg.className = type;
}

// ページ読み込み時にモードを読み込む
loadModes();
```

#### Step 5.3: HTMLテンプレートの作成
**新規ファイル**: `templates/index.html`

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obsidian Synapsis</title>
    <link rel="stylesheet" href="/static/css/style.css">
</head>
<body>
    <div class="container">
        <!-- 左ペイン: モード選択 -->
        <div class="sidebar">
            <h2>Synapsis</h2>
            <div id="modeTabs"></div>
        </div>

        <!-- 右ペイン: メインコンテンツ -->
        <div class="main-content">
            <h1 class="mode-title" id="modeTitle">読み込み中...</h1>
            <p class="mode-description" id="modeDescription"></p>

            <textarea id="content" placeholder="内容を入力..."></textarea>

            <div class="button-group">
                <button id="saveBtn" onclick="saveContent()">保存のみ</button>
                <button id="askAIBtn" onclick="askAI()">AIに質問</button>
            </div>

            <div id="message"></div>

            <div id="aiResponse">
                <h3>AI回答</h3>
                <div id="aiResponseContent"></div>
            </div>
        </div>
    </div>

    <script src="/static/js/app.js"></script>
</body>
</html>
```

**影響範囲**: main.pyのindex()関数
**リスク**: 低 (静的ファイルの分離のみ)
**所要時間**: 20分

---

### Phase 6: Controller層の実装 (影響度: 高)

#### Step 6.1: ヘルスチェックコントローラ
**新規ファイル**: `controllers/health_controller.py`

```python
"""ヘルスチェックコントローラ"""
from fastapi import APIRouter

router = APIRouter()


@router.get("/health")
async def health_check() -> dict[str, str]:
    """ヘルスチェックエンドポイント"""
    return {"status": "ok"}
```

#### Step 6.2: モードコントローラ
**新規ファイル**: `controllers/mode_controller.py`

```python
"""モード管理コントローラ"""
from fastapi import APIRouter
from models.responses import GetModesResponse
from services.mode_service import ModeService

router = APIRouter()


@router.get("/modes", response_model=GetModesResponse)
async def get_modes() -> GetModesResponse:
    """
    利用可能なモード一覧を取得

    Returns:
        モード一覧とデフォルトモード
    """
    return ModeService.get_modes()
```

#### Step 6.3: 保存コントローラ
**新規ファイル**: `controllers/save_controller.py`

```python
"""ファイル保存コントローラ"""
from fastapi import APIRouter, Depends
from pathlib import Path
from config import Config
from models.requests import SaveRequest
from models.responses import SaveResponse
from services.file_service import FileService
from services.git_service import GitService

router = APIRouter()


@router.post("/save", response_model=SaveResponse)
async def save_file(request: SaveRequest) -> SaveResponse:
    """
    リクエスト内容をファイルとして保存し、git commit & push

    - filename: ファイル名(省略時は日時ベースで自動生成)
    - content: 保存する内容
    """
    # ファイル名の決定
    if request.filename:
        filename = FileService.sanitize_filename(request.filename)
    else:
        filename = FileService.generate_filename()

    filepath = Config.DATA_DIR / filename

    # ファイル保存
    FileService.save_text_file(filepath, request.content)

    # Git commit & push を実行
    git_success, git_error = await GitService.commit_and_push(Config.DATA_DIR)

    return SaveResponse(
        success=True,
        filepath=str(filepath),
        message=f"ファイルを保存しました: {filename}",
        git_pushed=git_success,
        git_error=git_error,
    )
```

#### Step 6.4: AI処理コントローラ
**新規ファイル**: `controllers/ai_controller.py`

```python
"""AI処理コントローラ"""
from fastapi import APIRouter, Depends
from pathlib import Path
from config import Config
from models.requests import AskAIRequest
from models.responses import AskAIResponse
from services.ai_service import AIService
from services.file_service import FileService
from services.git_service import GitService
from services.mode_service import ModeService

router = APIRouter()


def get_ai_service() -> AIService:
    """AIServiceの依存性注入"""
    return AIService(
        api_key=Config.OPENAI_API_KEY,
        model=Config.OPENAI_MODEL
    )


@router.post("/ask-ai", response_model=AskAIResponse)
async def ask_ai(
    request: AskAIRequest,
    ai_service: AIService = Depends(get_ai_service)
) -> AskAIResponse:
    """
    ユーザーの質問をAIに送信し、回答をモード別ディレクトリに保存し、git commit & push

    - content: ユーザーの質問/入力
    - mode_id: 使用するモードのID
    - filename: ファイル名(省略時は日時ベースで自動生成)
    """
    # モードの検証と取得
    mode = ModeService.get_mode_by_id(request.mode_id)

    # プロンプト構築
    prompt = ai_service.build_prompt_from_template(
        mode.prompt_template,
        request.content
    )

    # AI呼び出し
    ai_response = ai_service.ask(prompt)

    # ファイル名の決定
    if request.filename:
        filename = FileService.sanitize_filename(request.filename)
    else:
        filename = FileService.generate_filename(prefix=mode.id)

    # 保存先パスの決定
    mode_dir = Config.DATA_DIR / mode.save_dir
    filepath = mode_dir / filename

    # 質問と回答をMarkdown形式で構築
    content_to_save = FileService.build_ai_response_content(
        mode.name,
        request.content,
        ai_response
    )

    # ファイル保存
    FileService.save_text_file(filepath, content_to_save)

    # Git commit & push を実行
    git_success, git_error = await GitService.commit_and_push(Config.DATA_DIR)

    return AskAIResponse(
        success=True,
        ai_response=ai_response,
        filepath=str(filepath),
        message=f"AI回答を保存しました: {mode.name} / {filename}",
        git_pushed=git_success,
        git_error=git_error,
    )
```

**影響範囲**: 全体 (main.pyの大幅な書き換え)
**リスク**: 中
**所要時間**: 40分

---

### Phase 7: main.pyのリファクタリング (影響度: 高)

#### Step 7.1: 新しいmain.pyの作成
**変更ファイル**: `main.py`

```python
"""
Obsidian Synapsis - ローカルからリクエストを受けてファイルとして保存するWebサーバー
"""
from pathlib import Path
from fastapi import FastAPI
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from starlette.requests import Request

from config import Config
from controllers import health_controller, mode_controller, save_controller, ai_controller

# 設定の初期化と検証
Config.validate()

# FastAPIアプリケーション
app = FastAPI(
    title="Obsidian Synapsis",
    description="ローカルからリクエストを受けてファイルとして保存",
)

# 静的ファイルのマウント
app.mount("/static", StaticFiles(directory=str(Config.STATIC_DIR)), name="static")

# テンプレートエンジンの設定
templates = Jinja2Templates(directory=str(Config.TEMPLATE_DIR))

# ルーターの登録
app.include_router(health_controller.router)
app.include_router(mode_controller.router)
app.include_router(save_controller.router)
app.include_router(ai_controller.router)


@app.on_event("startup")
async def startup_event() -> None:
    """起動時にdataディレクトリとモード別ディレクトリを作成"""
    Config.DATA_DIR.mkdir(exist_ok=True)

    # 各モードの保存ディレクトリを作成
    config = Config.load_modes_config()
    for mode_data in config["modes"]:
        mode_dir = Config.DATA_DIR / mode_data["save_dir"]
        mode_dir.mkdir(exist_ok=True)


@app.get("/", response_class=HTMLResponse)
async def index(request: Request) -> HTMLResponse:
    """Webページを表示"""
    return templates.TemplateResponse("index.html", {"request": request})


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

#### Step 7.2: controllers/__init__.pyの作成
**新規ファイル**: `controllers/__init__.py`

```python
"""コントローラモジュール"""
# 空のままでOK (または各コントローラをインポートしても良い)
```

**影響範囲**: main.py全体
**リスク**: 高 (全面的な書き換え)
**所要時間**: 30分

---

### Phase 8: テストと検証 (影響度: -)

#### Step 8.1: 起動確認
```bash
uvicorn main:app --reload
```

#### Step 8.2: 機能テスト
1. **ヘルスチェック**: `GET http://localhost:8000/health`
2. **モード取得**: `GET http://localhost:8000/modes`
3. **Web UI表示**: `http://localhost:8000/`
4. **ファイル保存**: 保存ボタンの動作確認
5. **AI質問**: AIに質問ボタンの動作確認
6. **Git操作**: data/ディレクトリでのcommit/push確認

#### Step 8.3: エラーハンドリング確認
- 無効なモードID
- ファイル名のパストラバーサル
- OpenAI APIエラー
- Git操作エラー

**影響範囲**: 全体
**リスク**: -
**所要時間**: 30分

---

### Phase 9: 旧コードの削除 (影響度: 低)

#### Step 9.1: main.pyから不要なコードを削除
- グローバル変数 `openai_client`, `modes_config`
- 関数 `load_modes_config()`, `get_mode_by_id()`, `build_prompt_from_template()`, `git_commit_and_push()`
- データモデル定義 (models/に移動済み)
- エンドポイント関数 (controllers/に移動済み)

**影響範囲**: main.pyのみ
**リスク**: 低 (既にPhase 7で実施済み)
**所要時間**: 10分

---

## 実装スケジュール

### 推奨実装順序
1. **Phase 1**: プロジェクト構造の準備 (5分)
2. **Phase 2**: モデル層の分離 (10分)
3. **Phase 3**: 設定管理の分離 (15分)
4. **Phase 4**: Service層の実装 (30分)
5. **Phase 5**: View層の分離 (20分)
6. **Phase 6**: Controller層の実装 (40分)
7. **Phase 7**: main.pyのリファクタリング (30分)
8. **Phase 8**: テストと検証 (30分)
9. **Phase 9**: 旧コードの削除 (10分)

**合計所要時間**: 約3時間

### リスク軽減戦略
1. **各フェーズ後に動作確認**: フェーズごとにサーバーを起動して確認
2. **Gitブランチ運用**: 新ブランチで作業し、動作確認後にmerge
3. **段階的な移行**: Phase 1-5まで完了後、一旦動作確認
4. **バックアップ**: 作業前にmain.pyのバックアップを作成

## 期待される効果

### 保守性の向上
- **責務の明確化**: 各層が単一の責任を持つ
- **コードの可読性**: ファイルサイズが小さく、理解しやすい
- **変更の局所化**: 変更時の影響範囲が限定される

### テスト容易性の向上
- **ユニットテスト可能**: 各サービスクラスを独立してテスト可能
- **モックの容易さ**: DIによりモックの注入が簡単

### 開発速度の向上
- **並行開発**: 異なる層を異なる開発者が作業可能
- **再利用性**: サービス層のロジックを他のエンドポイントから利用可能

## 注意事項

### 破壊的変更
- **なし**: 外部APIは変更されないため、クライアント側の修正不要

### データ移行
- **不要**: ディレクトリ構造は変更されない

### 後方互換性
- **完全保証**: すべてのエンドポイントとレスポンス形式は維持

## 今後の拡張性

### テストの追加
```
tests/
├── test_services/
│   ├── test_ai_service.py
│   ├── test_file_service.py
│   ├── test_git_service.py
│   └── test_mode_service.py
└── test_controllers/
    ├── test_ai_controller.py
    └── test_save_controller.py
```

### 新機能の追加が容易に
- 新しいモードの追加: modes_config.jsonの編集のみ
- 新しいエンドポイント: 新しいコントローラの追加のみ
- 新しいAIプロバイダ: AIServiceの拡張のみ

## まとめ

本リファクタリングにより、以下が実現されます:

1. ✅ **View層の完全分離**: HTML/CSS/JSが独立したファイルに
2. ✅ **Service層の導入**: ビジネスロジックが再利用可能に
3. ✅ **責務の明確化**: ask_ai()が適切に分割される
4. ✅ **テスト容易性**: 各コンポーネントが独立してテスト可能
5. ✅ **保守性の向上**: 変更時の影響範囲が限定される

実装時間は約3時間、リスクは段階的アプローチにより最小化されます。
