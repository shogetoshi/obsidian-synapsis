# Issue 0002: 複数モード機能実装計画

## Issue概要
- 複数の用途に対応できるタブ切り替え式のインターフェースを実装
- 各モードは独自のプロンプトテンプレートと保存先を持つ
- 左ペインにタブ名を縦に並べて表示

## 現状のアーキテクチャ分析

### 既存の構成
- **フレームワーク**: FastAPI (単一ファイル構成)
- **主要ファイル**: `main.py`
- **現在の機能**:
  - テキスト直接保存 (`/save`)
  - AI問い合わせ (`/ask-ai`)
- **保存先**: `data/` ディレクトリ直下
- **UI**: インラインHTML (SPAスタイル)
- **AIモデル**: OpenAI GPT-4o

### 既存のデータ構造
```python
class AskAIRequest(BaseModel):
    content: str
    filename: str | None = None

class AskAIResponse(BaseModel):
    success: bool
    ai_response: str
    filepath: str
    message: str
```

## 実装計画

### 1. データ構造の設計

#### 1.1 モード定義データ構造
**新規作成ファイル**: `modes_config.json`

```json
{
  "modes": [
    {
      "id": "general",
      "name": "一般的質問",
      "prompt_template": "ユーザーの質問に回答してください。\n\n質問: {content}",
      "save_dir": "general",
      "description": "一般的な質問や相談に対応します"
    },
    {
      "id": "translate",
      "name": "翻訳",
      "prompt_template": "以下の文章を日本語に翻訳してください。\n\n原文: {content}",
      "save_dir": "translate",
      "description": "テキストを日本語に翻訳します"
    },
    {
      "id": "summarize",
      "name": "要約",
      "prompt_template": "以下のWebページまたはテキストを要約してください。\n\n内容: {content}",
      "save_dir": "summarize",
      "description": "長文やWebページを要約します"
    }
  ],
  "default_mode": "general"
}
```

#### 1.2 Pythonデータモデルの追加
**変更ファイル**: `main.py`

```python
from typing import Literal

class ModeConfig(BaseModel):
    """モード設定のスキーマ"""
    id: str
    name: str
    prompt_template: str
    save_dir: str
    description: str

class ModesConfig(BaseModel):
    """モード設定全体のスキーマ"""
    modes: list[ModeConfig]
    default_mode: str

class AskAIRequest(BaseModel):
    """AI問い合わせリクエストのスキーマ"""
    content: str
    mode_id: str = "general"  # モードIDを追加
    filename: str | None = None

class GetModesResponse(BaseModel):
    """モード一覧取得レスポンスのスキーマ"""
    modes: list[ModeConfig]
    default_mode: str
```

### 2. 変更が必要な既存ファイル

#### 2.1 `main.py` の変更内容

##### 2.1.1 グローバル変数とモード設定読み込み
```python
import json
from typing import Dict

# 設定ファイルのパス
CONFIG_FILE = Path(__file__).parent / "modes_config.json"

# モード設定をグローバル変数として保持
modes_config: ModesConfig | None = None

@app.on_event("startup")
async def startup_event() -> None:
    """起動時にdataディレクトリとモード設定を読み込み"""
    global modes_config

    # dataディレクトリ作成
    DATA_DIR.mkdir(exist_ok=True)

    # OpenAI APIキーの存在確認
    if not os.getenv("OPENAI_API_KEY"):
        raise RuntimeError("OPENAI_API_KEY環境変数が設定されていません")

    # モード設定の読み込み
    if not CONFIG_FILE.exists():
        raise RuntimeError(f"モード設定ファイルが見つかりません: {CONFIG_FILE}")

    try:
        config_data = json.loads(CONFIG_FILE.read_text(encoding="utf-8"))
        modes_config = ModesConfig(**config_data)

        # 各モードの保存ディレクトリを作成
        for mode in modes_config.modes:
            mode_dir = DATA_DIR / mode.save_dir
            mode_dir.mkdir(exist_ok=True)

        print(f"モード設定を読み込みました: {len(modes_config.modes)}個のモード")
    except Exception as e:
        raise RuntimeError(f"モード設定の読み込みに失敗: {e}") from e
```

##### 2.1.2 新規エンドポイント: モード一覧取得
```python
@app.get("/modes", response_model=GetModesResponse)
async def get_modes() -> GetModesResponse:
    """
    利用可能なモード一覧を取得

    Returns:
        モード一覧とデフォルトモード
    """
    if modes_config is None:
        raise HTTPException(status_code=500, detail="モード設定が読み込まれていません")

    return GetModesResponse(
        modes=modes_config.modes,
        default_mode=modes_config.default_mode,
    )
```

##### 2.1.3 `/ask-ai`エンドポイントの修正
```python
@app.post("/ask-ai", response_model=AskAIResponse)
async def ask_ai(request: AskAIRequest) -> AskAIResponse:
    """
    ユーザーの質問をAIに送信し、回答をモード別ディレクトリに保存

    - content: ユーザーの質問/入力
    - mode_id: 使用するモードのID
    - filename: ファイル名(省略時は日時ベースで自動生成)
    """
    if modes_config is None:
        raise HTTPException(status_code=500, detail="モード設定が読み込まれていません")

    # モードの検証
    mode = next((m for m in modes_config.modes if m.id == request.mode_id), None)
    if mode is None:
        raise HTTPException(
            status_code=400,
            detail=f"無効なモードID: {request.mode_id}"
        )

    try:
        # プロンプトテンプレートを適用
        prompt = mode.prompt_template.format(content=request.content)

        # OpenAI APIを呼び出し
        response = openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7,
        )

        ai_response = response.choices[0].message.content

        # ファイル名の決定
        if request.filename:
            filename = request.filename
        else:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{mode.id}_{timestamp}.md"

        # パストラバーサル対策
        safe_filename = Path(filename).name
        if not safe_filename:
            raise HTTPException(status_code=400, detail="無効なファイル名です")

        # モード別ディレクトリに保存
        mode_dir = DATA_DIR / mode.save_dir
        filepath = mode_dir / safe_filename

        # 質問と回答をMarkdown形式で保存
        content_to_save = (
            f"# {mode.name}\n\n"
            f"## 入力\n\n{request.content}\n\n"
            f"## AI回答\n\n{ai_response}\n"
        )
        filepath.write_text(content_to_save, encoding="utf-8")

        return AskAIResponse(
            success=True,
            ai_response=ai_response,
            filepath=str(filepath),
            message=f"AI回答を保存しました: {mode.name} / {safe_filename}",
        )

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"AI処理中にエラーが発生しました: {e!s}"
        ) from e
```

##### 2.1.4 HTMLの大幅な変更
**変更ファイル**: `main.py` の `index()` 関数

UIを2ペインレイアウトに変更:
- 左ペイン: モード選択タブ (縦並び)
- 右ペイン: 入力フィールドとボタン、AI回答表示エリア

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obsidian Synapsis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: #1e1e1e;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
        }

        /* 左ペイン: タブナビゲーション */
        .sidebar {
            width: 250px;
            background: #252525;
            border-right: 1px solid #444;
            padding: 20px 0;
            overflow-y: auto;
        }
        .sidebar h2 {
            color: #7c3aed;
            padding: 0 20px 20px;
            font-size: 24px;
        }
        .mode-tab {
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }
        .mode-tab:hover {
            background: #2d2d2d;
        }
        .mode-tab.active {
            background: #2d2d2d;
            border-left-color: #7c3aed;
        }
        .mode-tab-name {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 4px;
        }
        .mode-tab-desc {
            font-size: 13px;
            color: #999;
        }

        /* 右ペイン: メインコンテンツ */
        .main-content {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
        }
        .mode-title {
            color: #7c3aed;
            font-size: 28px;
            margin-bottom: 8px;
        }
        .mode-description {
            color: #999;
            margin-bottom: 24px;
            font-size: 14px;
        }
        textarea {
            width: 100%;
            height: 300px;
            padding: 16px;
            font-size: 16px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #2d2d2d;
            color: #e0e0e0;
            resize: vertical;
            font-family: inherit;
        }
        .button-group {
            margin-top: 16px;
            display: flex;
            gap: 12px;
        }
        button {
            padding: 12px 32px;
            font-size: 16px;
            background: #7c3aed;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover { background: #6d28d9; }
        button:disabled { background: #666; cursor: not-allowed; }
        #askAIBtn { background: #10b981; }
        #askAIBtn:hover { background: #059669; }

        #message {
            margin-top: 16px;
            padding: 12px;
            border-radius: 8px;
            display: none;
        }
        .success { background: #065f46; display: block !important; }
        .error { background: #991b1b; display: block !important; }

        #aiResponse {
            margin-top: 24px;
            padding: 20px;
            background: #2d2d2d;
            border-radius: 8px;
            display: none;
        }
        #aiResponse h3 {
            color: #10b981;
            margin-top: 0;
            margin-bottom: 16px;
        }
        #aiResponseContent {
            white-space: pre-wrap;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 左ペイン: モード選択 -->
        <div class="sidebar">
            <h2>Synapsis</h2>
            <div id="modeTabs"></div>
        </div>

        <!-- 右ペイン: メインコンテンツ -->
        <div class="main-content">
            <h1 class="mode-title" id="modeTitle">読み込み中...</h1>
            <p class="mode-description" id="modeDescription"></p>

            <textarea id="content" placeholder="内容を入力..."></textarea>

            <div class="button-group">
                <button id="saveBtn" onclick="saveContent()">保存のみ</button>
                <button id="askAIBtn" onclick="askAI()">AIに質問</button>
            </div>

            <div id="message"></div>

            <div id="aiResponse">
                <h3>AI回答</h3>
                <div id="aiResponseContent"></div>
            </div>
        </div>
    </div>

    <script>
        let currentMode = null;
        let modesData = null;

        // ページ読み込み時にモード一覧を取得
        async function loadModes() {
            try {
                const res = await fetch('/modes');
                const data = await res.json();
                modesData = data;

                // タブを生成
                const tabsContainer = document.getElementById('modeTabs');
                data.modes.forEach(mode => {
                    const tab = document.createElement('div');
                    tab.className = 'mode-tab';
                    tab.onclick = () => selectMode(mode.id);
                    tab.innerHTML = `
                        <div class="mode-tab-name">${mode.name}</div>
                        <div class="mode-tab-desc">${mode.description}</div>
                    `;
                    tab.dataset.modeId = mode.id;
                    tabsContainer.appendChild(tab);
                });

                // デフォルトモードを選択
                selectMode(data.default_mode);
            } catch (e) {
                showMessage('モード読み込みエラー: ' + e.message, 'error');
            }
        }

        // モードを選択
        function selectMode(modeId) {
            const mode = modesData.modes.find(m => m.id === modeId);
            if (!mode) return;

            currentMode = mode;

            // タブのアクティブ状態を更新
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.modeId === modeId);
            });

            // タイトルと説明を更新
            document.getElementById('modeTitle').textContent = mode.name;
            document.getElementById('modeDescription').textContent = mode.description;

            // AI回答を非表示
            document.getElementById('aiResponse').style.display = 'none';
            document.getElementById('message').style.display = 'none';
        }

        // 保存のみ
        async function saveContent() {
            const content = document.getElementById('content').value;
            const btn = document.getElementById('saveBtn');

            if (!content.trim()) {
                showMessage('内容を入力してください', 'error');
                return;
            }

            btn.disabled = true;
            btn.textContent = '保存中...';

            try {
                const res = await fetch('/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content })
                });
                const data = await res.json();

                if (res.ok) {
                    showMessage(data.message, 'success');
                    document.getElementById('content').value = '';
                } else {
                    showMessage(data.detail || '保存に失敗しました', 'error');
                }
            } catch (e) {
                showMessage('エラー: ' + e.message, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = '保存のみ';
            }
        }

        // AIに質問
        async function askAI() {
            const content = document.getElementById('content').value;
            const btn = document.getElementById('askAIBtn');
            const responseDiv = document.getElementById('aiResponse');
            const responseContent = document.getElementById('aiResponseContent');

            if (!content.trim()) {
                showMessage('内容を入力してください', 'error');
                return;
            }

            if (!currentMode) {
                showMessage('モードが選択されていません', 'error');
                return;
            }

            btn.disabled = true;
            btn.textContent = 'AI処理中...';
            responseDiv.style.display = 'none';

            try {
                const res = await fetch('/ask-ai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content,
                        mode_id: currentMode.id
                    })
                });
                const data = await res.json();

                if (res.ok) {
                    showMessage(data.message, 'success');
                    responseContent.textContent = data.ai_response;
                    responseDiv.style.display = 'block';
                } else {
                    showMessage(data.detail || 'AI処理に失敗しました', 'error');
                }
            } catch (e) {
                showMessage('エラー: ' + e.message, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'AIに質問';
            }
        }

        function showMessage(text, type) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.className = type;
        }

        // ページ読み込み時にモードを読み込む
        loadModes();
    </script>
</body>
</html>
```

### 3. 新規作成が必要なファイル

#### 3.1 `modes_config.json`
上記「1.1 モード定義データ構造」を参照

#### 3.2 `.gitignore` の更新
```gitignore
.env
data/
*.pyc
__pycache__/
.venv/
*.egg-info/
```

### 4. ディレクトリ構造

実装後のディレクトリ構造:
```
obsidian-synapsis/
├── main.py                    # 変更: モード対応
├── modes_config.json          # 新規: モード定義
├── pyproject.toml             # 変更なし
├── .env                       # 既存
├── .gitignore                 # 更新
├── data/                      # 自動生成
│   ├── general/              # 新規: 一般質問用
│   ├── translate/            # 新規: 翻訳用
│   └── summarize/            # 新規: 要約用
└── doc/
    ├── issue/
    │   ├── 0001-AI回答.md
    │   └── 0002-複数モード.md
    └── plan/
        ├── 0001-AI回答機能実装計画.md
        └── 0002-複数モード機能実装計画.md  # 本ファイル
```

### 5. 実装順序

#### ステップ1: モード設定ファイルの作成
1. `modes_config.json` を作成
2. 初期モード3つを定義

#### ステップ2: バックエンドの実装
1. `main.py` にモード関連のデータモデルを追加
2. 起動時のモード設定読み込み処理を実装
3. `/modes` エンドポイントを追加
4. `/ask-ai` エンドポイントを修正
   - `mode_id` パラメータに対応
   - プロンプトテンプレートの適用
   - モード別ディレクトリへの保存

#### ステップ3: フロントエンドの実装
1. 2ペインレイアウトのHTMLを実装
2. モード一覧取得とタブ生成のJavaScriptを実装
3. モード選択機能の実装
4. `/ask-ai` APIコールを `mode_id` 対応に修正
5. CSSでレスポンシブ対応

#### ステップ4: テストと動作確認
1. サーバー起動確認
2. モード切り替え動作確認
3. 各モードでのAI問い合わせ確認
4. ファイル保存先の確認
5. エラーケースの確認

### 6. UIの変更点詳細

#### 6.1 レイアウト
- **変更前**: 単一ペイン、縦スクロール
- **変更後**: 2ペインレイアウト (左: ナビゲーション、右: メインコンテンツ)

#### 6.2 左ペイン (サイドバー)
- アプリケーション名表示
- モードタブを縦に並べて表示
- 各タブには名前と説明を表示
- アクティブなタブを視覚的に強調

#### 6.3 右ペイン (メインコンテンツ)
- 現在選択中のモード名を大きく表示
- モードの説明文を表示
- テキスト入力エリア
- 「保存のみ」と「AIに質問」の2つのボタン
- メッセージ表示エリア
- AI回答表示エリア

#### 6.4 ユーザー体験の流れ
1. ページ読み込み時に自動でモード一覧を取得
2. デフォルトモード(一般的質問)が選択された状態で表示
3. ユーザーが左ペインからモードを選択
4. 右ペインのタイトルと説明が更新される
5. テキストを入力して「AIに質問」をクリック
6. AI回答が表示され、モード別ディレクトリに保存される

### 7. 考慮事項

#### 7.1 拡張性
- 新しいモードは `modes_config.json` に追加するだけで対応可能
- プロンプトテンプレートのカスタマイズが容易
- 保存先ディレクトリもモードごとに柔軟に設定可能

#### 7.2 後方互換性
- 既存の `/save` エンドポイントは変更なし
- 既存の `/ask-ai` エンドポイントは `mode_id` がオプション (デフォルト値あり)

#### 7.3 セキュリティ
- パストラバーサル対策は既存と同様に実施
- モードIDのバリデーションを実装
- 不正なモードIDへのアクセスを拒否

#### 7.4 パフォーマンス
- モード設定は起動時に一度だけ読み込み
- グローバル変数として保持してアクセス高速化

#### 7.5 エラーハンドリング
- モード設定ファイルの読み込みエラー
- 存在しないモードIDの指定エラー
- プロンプトテンプレートの適用エラー

#### 7.6 今後の拡張案
1. **モードの動的追加**: 管理画面からモードを追加・編集
2. **カスタムパラメータ**: モードごとにAI temperature等を設定
3. **モード別履歴**: 各モードでの問い合わせ履歴を表示
4. **エクスポート機能**: モード別にまとめてファイルをエクスポート
5. **プロンプト変数拡張**: `{content}` 以外の変数にも対応

### 8. テスト計画

#### 8.1 手動テスト項目

##### 正常系
1. サーバー起動時にモード設定が正しく読み込まれる
2. 各モード用のディレクトリが自動生成される
3. `/modes` エンドポイントでモード一覧を取得できる
4. 左ペインにモードタブが表示される
5. タブをクリックすると選択状態が変わる
6. 選択したモードのタイトルと説明が表示される
7. 各モードでAI問い合わせができる
8. AI回答がモード別ディレクトリに保存される
9. ファイル名にモードIDが含まれる
10. 保存されたファイルに正しい内容が含まれる

##### 異常系
1. `modes_config.json` が存在しない場合のエラー
2. 不正なJSON形式のエラー
3. 存在しないモードIDを指定した場合のエラー
4. 空の入力でAI問い合わせした場合のエラー

#### 8.2 自動テスト (今後の課題)
- pytest でのエンドポイントテスト
- モード設定の読み込みテスト
- プロンプトテンプレート適用のテスト

### 9. ドキュメント更新

#### 9.1 README.md の更新項目
- モード機能の説明
- `modes_config.json` の設定方法
- 新しいモードの追加方法
- プロンプトテンプレートの書き方

#### 9.2 設定ファイルの例
- `modes_config.json.example` を作成
- カスタムモードの例を追加

## まとめ

本実装計画では、以下を実現します:

### 主要な変更点
1. **モード設定システム**: JSON形式で柔軟に設定可能
2. **2ペインUI**: 左にモード選択、右にメインコンテンツ
3. **プロンプトテンプレート**: モードごとにAIへの指示をカスタマイズ
4. **保存先の分離**: モード別にディレクトリを分けて整理

### 影響範囲
- **main.py**: 大幅な変更 (データモデル、エンドポイント、HTML)
- **新規ファイル**: modes_config.json
- **ディレクトリ構造**: data/ 配下にモード別ディレクトリを作成

### 実装後の利点
- 用途に応じた使い分けが可能
- 新しいモードの追加が容易
- ファイルがモード別に整理される
- プロンプトのカスタマイズが簡単
- UIが直感的で使いやすい

実装後は、ユーザーが左ペインから目的に応じたモード(一般質問、翻訳、要約)を選択し、右ペインで入力と操作を行う、直感的なインターフェースが完成します。
